/**
 * Bundle of @livelybone/date-generator
 * Generated: 2019-07-31
 * Version: 3.3.0
 * License: MIT
 * Author: livelybone (2631541504@qq.com)
 */

/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
var zeroFill = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0';
  width -= number.toString().length;
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
};

/**
 * @param {Integer} num
 * @return {Boolean}
 * */
function isNonNegInt(num) {
  return +num === Math.floor(+num) && +num >= 0
}

/**
 * @param {Object} o1
 * @param {Object} o2
 * @return {Object}
 * */
function objAssign(o1, o2) {
  o1 = typeof o1 === 'object' ? o1 : {};
  o2 = typeof o2 === 'object' ? o2 : {};
  return Object.keys(o1).concat(Object.keys(o2)).reduce(function (pre, k) {
    if (!(k in pre)) pre[k] = o2[k] !== undefined ? o2[k] : o1[k];
    return pre
  }, {})
}

/**
 * @param {Number} val
 * @param {Number} div
 * @return {Number}
 * */
function mod(val, div) {
  return (val % div + div) % div
}

/**
 * @param {Number|String} year
 * @return {Boolean}
 * */
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)
}

/**
 * @param {Integer} year
 * @param {Integer} month
 * @return {Integer}
 * */
function getMonthLen(year, month) {
  year = +year;
  month = +month;

  if (month === 2) {
    return isLeapYear(year) ? 29 : 28
  }

  return Math.ceil(Math.abs(month - 7.5)) % 2 === 1 ? 31 : 30
}

/**
 * @param {Integer} defaultMax
 * */
function getIntervalVal(defaultMax) {
  /**
   * @param {Object<{interval: Integer, min: Integer, max: Integer}>} options
   * */
  return function (options) {
    options = objAssign({ interval: 1, min: 0, max: defaultMax - 1 }, options);
    var reset = function (k) {
      if (!isNonNegInt(options[k])) {
        options[k] = Math.ceil(Math.abs(options[k]));
      }
    };
    reset('interval');
    reset('min');
    reset('max');

    var arr = [];
    for (var i = 0; i < defaultMax; i += options.interval) {
      arr.push({
        value: zeroFill(2, i),
        max: defaultMax,
        canBeChose: i >= options.min && i <= options.max,
      });
    }
    return arr
  }
}

/**
 * @param {String} date, format: /^(\d{4})-?(\d{1,2})?-?(\d{1,2})?$/
 * @return {Object<{year: Integer, month: Integer, date: Integer}>}
 * */
function parseDate(date) {
  var reg = /^(\d{4})-?(\d{1,2})?-?(\d{1,2})?$/;

  if (!reg.test(date)) throw new Error('Utils.parseDate: Param date is invalid. The right example: 2018[-02][-01]')

  var arr = date.match(reg);

  if (!arr) return null

  var dateObj = { year: +arr[1], month: mod(+arr[2] || 1, 13) };

  dateObj.date = mod(+arr[3] || 1, getMonthLen(dateObj.year, dateObj.month) + 1);

  return dateObj
}

/**
 * @param {String} time, format: /^(\d{1,2}):?(\d{1,2})?:?(\d{1,2})?$/
 * @return {Object<{hour: Integer, minute: Integer, second: Integer}>}
 * */
function parseTime(time) {
  var reg = /^(\d{1,2}):?(\d{1,2})?:?(\d{1,2})?$/;

  if (!reg.test(time)) throw new Error('Utils.parseDate: Param time is invalid. The right example: 18[:02][:01]')

  var arr = time.match(reg);

  if (!arr) return null

  return { hour: mod(+arr[1], 24), minute: mod(+arr[2] || 0, 60), second: mod(+arr[3] || 0, 60) }
}

/**
 * @param {Integer} year
 * @param {Integer} month
 * @param {Object} options -> {min: String, max: String}, string format: /^(\d{4})-?(\d{1,2})?-?(\d{1,2})?$/
 * @return {Array<Array<{year: Integer, month: Integer, date: Integer, isInThisMonth: Boolean, canBeChose: Boolean}>>}
 * */
function gntDate$$1(year, month, options) {
  if (!isNonNegInt(year) || !isNonNegInt(month)) {
    throw new Error('Prop year and month must be a non-negative number')
  }

  year = +year;
  month = +month;

  var minD = objAssign({ year: 0, month: 0, date: 0 }, options.min && parseDate(options.min));
  var maxD = objAssign({ year: Infinity, month: Infinity, date: Infinity },
    options.max && parseDate(options.max));

  var incrementDate = 1;
  var nextIncrementDate = 1;
  var firstDay = getDay(year, month, incrementDate);
  var fillDateLen = firstDay & 7;
  fillDateLen = fillDateLen === 0 ? 7 : fillDateLen;

  var prevMonth = month - 1 < 1 ? { year: year - 1, month: 12 } : { year: year, month: month - 1 };
  var prevMonthLen = getMonthLen(prevMonth.year, prevMonth.month);
  var monthLen = getMonthLen(year, month);
  var nextMonth = month + 1 > 12 ? { year: year + 1, month: 1 } : { year: year, month: month + 1 };

  var lineLen = Math.ceil(31 / 7) + 1;

  var calendar = [];

  var canChose = function (year, month, date) {
    var compare = function (t, flag) {
      flag = flag || 1;
      return (year - t.year) * flag > 0
        || (year === t.year && (month - t.month) * flag > 0)
        || (year === t.year && month === t.month && (date - t.date) * flag >= 0)
    };
    return compare(minD) && compare(maxD, -1)
  };

  for (var i = 0; i < lineLen; i++) {
    calendar[i] = [];

    for (var j = 0; j < 7; j++) {
      if (i === 0 && j < fillDateLen) {
        var d = prevMonthLen - fillDateLen + 1 + j;
        calendar[i][j] = {
          year: zeroFill(4, prevMonth.year),
          month: zeroFill(2, prevMonth.month),
          date: zeroFill(2, d),
          isInThisMonth: false,
          canBeChose: canChose(prevMonth.year, prevMonth.month, d)
        };
        continue
      }
      if (incrementDate <= monthLen) {
        calendar[i][j] = {
          year: zeroFill(4, year),
          month: zeroFill(2, month),
          date: zeroFill(2, incrementDate),
          isInThisMonth: true,
          canBeChose: canChose(year, month, incrementDate)
        };
        incrementDate++;
      } else {
        calendar[i][j] = {
          year: zeroFill(4, nextMonth.year),
          month: zeroFill(2, nextMonth.month),
          date: zeroFill(2, nextIncrementDate),
          isInThisMonth: false,
          canBeChose: canChose(nextMonth.year, nextMonth.month, nextIncrementDate)
        };
        nextIncrementDate++;
      }
    }
  }

  return calendar
}

/**
 * @param {Object<{interval: Integer, min: Integer, max: Integer}>} options
 * */
var getHour = getIntervalVal(24);

/**
 * @param {Object<{interval: Integer, min: Integer, max: Integer}>} options
 * */
var getMinute = getIntervalVal(60);

/**
 * @param {Integer} year
 * @param {Object<{min: String, max: String}>} options, string format: /^(\d{4})-?(\d{1,2})?-?(\d{1,2})?$/
 * @return {Array<Array<{year: Integer, month: Integer, canBeChose: Boolean}>>}
 * */
function gntMonth(year, options) {
  year = +year;
  var splitLen = options.splitLen || 3;
  var min = options.min && parseDate(options.min, 'month');
  var max = options.max && parseDate(options.max, 'month');

  var arr = [];
  var line = Math.ceil(12 / splitLen);
  for (var i = 0; i < line; i++) {
    arr[i] = [];
    for (var j = 0; j < splitLen; j++) {
      var month = i * splitLen + j + 1;
      if (month > 12) break
      arr[i].push({
        year: zeroFill(4, year),
        month: zeroFill(2, month),
        canBeChose: (!min && !max)
        || (min && max && (year > min.year || (year === min.year && month >= min.month)) && (year < max.year || (year === max.year && month <= max.month)))
        || (!max && min && (year > min.year || (year === min.year && month >= min.month)))
        || (!min && max && (year < max.year || (year === max.year && month <= max.month)))
      });
    }
  }

  return arr
}

/**
 * @param {Object<{interval: Integer, min: Integer, max: Integer}>} options
 * */
var getSecond = getIntervalVal(60);

/**
 * @param {Integer} year
 * @param {Integer} month
 * @param {Integer} date
 * @return {Integer} [0,1,2,3,4,5,6]
 * */
function getDay(year, month, date) {
  year = +year;
  month = +month;
  date = +date;

  var c, y, m;
  if (month === 1 || month === 2) {
    c = Math.floor((year - 1) / 100);
    y = (year - 1) % 100;
    m = month + 12;
  } else {
    c = Math.floor(year / 100);
    y = year % 100;
    m = month;
  }

  return mod(y + Math.floor(y / 4) + Math.floor(c / 4) - 2 * c + Math.floor(26 * (m + 1) / 10) + date - 1, 7)
}

/**
 * @param {Integer} start
 * @param {Integer} len
 * @param {Object<{min: Integer, max: Integer}>} options ->
 * @return {Array<{year: Integer, canBeChose: Boolean}>}
 * */
function gntYear(start, len, options) {
  if (!isNonNegInt(+start) || !isNonNegInt(+len)) {
    throw new Error('Prop start and len must be a non-negative number')
  }

  var splitLen = options.splitLen || 3;
  var min = options.min || null;
  var max = options.max || null;

  var arr = [];
  var line = Math.ceil(len / splitLen);
  for (var i = 0; i < line; i++) {
    arr[i] = [];
    for (var j = 0; j < splitLen; j++) {
      var year = start + i * splitLen + j;
      if (year - start + 1 > len) break
      arr[i].push({
        year: zeroFill(4, year),
        canBeChose: (!min && !max)
        || (min && max && year >= min && year <= max)
        || (!min && max && year <= max)
        || (!max && min && year >= min)
      });
    }
  }

  return arr
}

export { gntYear, gntMonth, gntDate$$1 as gntDate, getDay, getHour, getMinute, getSecond, zeroFill as fillTo, isNonNegInt, objAssign, mod, isLeapYear, getMonthLen, getIntervalVal, parseDate, parseTime };
