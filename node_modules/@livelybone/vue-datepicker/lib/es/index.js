/**
 * Bundle of @livelybone/vue-datepicker
 * Generated: 2019-08-02
 * Version: 3.1.0
 * License: MIT
 * Author: 2631541504@qq.com
 */

import { parseDate, gntYear, gntMonth, gntDate, fillTo, parseTime, getHour, getMinute, getSecond } from '@livelybone/date-generator';
import { objectDeepMerge } from '@livelybone/copy';
import VuePopper from '@livelybone/vue-popper';
import VueScrollbar from 'vue-scrollbar-live';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var dateReg = /^((\d{4})-?(\d{1,2})?-?(\d{1,2})?)/;
function dateCompare(d1, d2) {
  var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'date';
  if (!d2 || !d1) return true;
  var d11 = _typeof(d1) === 'object' ? d1 : parseDate(d1);
  var d21 = _typeof(d2) === 'object' ? d2 : parseDate(d2);

  if (flag !== 0) {
    if (type === 'year') return (d11.year - d21.year) * flag >= 0;

    if (type === 'month') {
      return (d11.year - d21.year) * flag > 0 || +d11.year === +d21.year && (d11.month - d21.month) * flag >= 0;
    }

    return (d11.year - d21.year) * flag > 0 || +d11.year === +d21.year && (d11.month - d21.month) * flag > 0 || +d11.year === +d21.year && +d11.month === +d21.month && (d11.date - d21.date) * flag >= 0;
  }

  if (type === 'year') return d11.year - d21.year === 0;

  if (type === 'month') {
    return +d11.year === +d21.year && d11.month - d21.month === 0;
  }

  return +d11.year === +d21.year && +d11.month === +d21.month && d11.date - d21.date === 0;
}

var script = {
  name: 'Dates',
  beforeMount: function beforeMount() {
    var _this = this;

    this.setValue(function () {
      var now = new Date();
      _this.dateObj = {
        year: now.getFullYear(),
        month: now.getMonth() + 1,
        date: now.getDate()
      };
    });
  },
  props: {
    value: String,
    type: String,
    minDate: String,
    maxDate: String,
    dayStr: Array
  },
  data: function data() {
    return {
      year: '',
      month: '',
      date: ''
    };
  },
  computed: {
    choseType: function choseType() {
      return /^(year|month|date|time)$/.test(this.type) ? this.type : 'date';
    },
    $dayStr: function $dayStr() {
      return !this.dayStr || this.dayStr.length < 7 || this.dayStr.some(function (day) {
        return typeof day !== 'string';
      }) ? ['日', '一', '二', '三', '四', '五', '六'] : this.dayStr.slice(0, 7);
    },
    minD: function minD() {
      return _objectSpread2({}, {
        year: 0,
        month: 0,
        date: 0
      }, {}, this.minDate && parseDate(this.minDate));
    },
    maxD: function maxD() {
      return _objectSpread2({}, {
        year: Infinity,
        month: Infinity,
        date: Infinity
      }, {}, this.maxDate && parseDate(this.maxDate));
    },
    dateObj: {
      get: function get() {
        return {
          year: this.year,
          month: this.month,
          date: this.date
        };
      },
      set: function set(val) {
        var fillTo$1 = fillTo;
        this.year = fillTo$1(4, val.year);
        this.month = fillTo$1(2, val.month);
        this.date = fillTo$1(2, val.date);
      }
    },
    years: function years() {
      if (!this.year) return [];
      return gntYear(Math.floor(this.year / 10 - 0.5) * 10 + 1, 10, {
        splitLen: 3,
        min: this.minD.year,
        max: this.maxD.year
      });
    },
    months: function months() {
      return gntMonth(this.year, {
        splitLen: 3,
        min: this.minDate,
        max: this.maxDate
      });
    },
    dates: function dates() {
      return gntDate(this.year, this.month, {
        min: this.minDate,
        max: this.maxDate
      });
    },
    pickerItems: function pickerItems() {
      if (this.choseType === 'year') {
        return this.years;
      }

      if (this.choseType === 'month') {
        return this.months;
      }

      return this.dates;
    }
  },
  watch: {
    pickerItems: function pickerItems(val) {
      var showBtn = null;

      if (this.choseType === 'date') {
        var dates = this.getDate({
          date: 1
        });
        showBtn = {
          prev: dateCompare(dates[0], this.minDate),
          next: dateCompare(dates[1], this.maxDate, -1)
        };
      } else if (this.choseType === 'month' || this.choseType === 'year') {
        var first = val[0][0];
        var lastRow = val[val.length - 1];
        var last = lastRow[lastRow.length - 1];

        if (this.choseType === 'month') {
          showBtn = {
            prev: dateCompare({
              year: first.year - 1,
              month: 12
            }, this.minDate, 1, 'month'),
            next: dateCompare({
              year: +last.year + 1,
              month: 1
            }, this.maxDate, -1, 'month')
          };
        } else {
          showBtn = {
            prev: dateCompare({
              year: first.year - 1
            }, this.minDate, 1, 'year'),
            next: dateCompare({
              year: +last.year + 1
            }, this.maxDate, -1, 'year')
          };
        }
      } else {
        showBtn = {
          prev: dateCompare(this.getDate({
            step: -1
          }), this.minDate, 1),
          next: dateCompare(this.getDate({
            step: 1
          }), this.maxDate, -1)
        };
      }

      this.$emit('emitData', {
        showBtn: showBtn,
        items: val
      });
    },
    value: function value() {
      this.setValue();
    }
  },
  methods: {
    setValue: function setValue(cb) {
      var date = this.value && parseDate(this.value.match(dateReg)[1]);

      if (date) {
        this.dateObj = date;
      } else if (cb) {
        cb();
      }

      this.$emit('chose', _objectSpread2({}, this.dateObj));
    },
    chose: function chose(item) {
      if (item.canBeChose) {
        if (this.choseType === 'date') {
          this.date = item.date;
          this.$emit('chose', _objectSpread2({
            type: 'date'
          }, item));
        } else if (this.choseType === 'month') {
          this.month = item.month;
          this.$emit('chose', _objectSpread2({
            type: 'month'
          }, item));
        } else if (this.choseType === 'year') {
          this.year = item.year;
          this.$emit('chose', _objectSpread2({
            type: 'year'
          }, item));
        }
      }
    },
    isSelected: function isSelected(item) {
      if (this.choseType === 'date') {
        return item.year === this.year && item.month === this.month && item.date === this.date;
      }

      if (this.choseType === 'month') {
        return item.year === this.year && item.month === this.month;
      }

      return item.year === this.year;
    },
    to: function to() {
      var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (this.choseType === 'year') {
        this.dateObj = _objectSpread2({}, this.dateObj, {
          year: +this.year + 10 * step
        });
        this.$emit('to', _objectSpread2({
          type: 'ten-year'
        }, this.dateObj));
      } else if (this.choseType === 'month') {
        this.dateObj = _objectSpread2({}, this.dateObj, {
          year: +this.year + step
        });
        this.$emit('to', _objectSpread2({
          type: 'year'
        }, this.dateObj));
      } else if (this.choseType === 'date') {
        var month = +this.month + step;

        if (step > 0 && month > 12 || step < 0 && month < 1) {
          this.dateObj = _objectSpread2({}, this.dateObj, {
            year: +this.year + step,
            month: step > 0 ? 1 : 12
          });
        } else {
          this.dateObj = _objectSpread2({}, this.dateObj, {
            month: month
          });
        }

        this.$emit('to', _objectSpread2({
          type: 'month'
        }, this.dateObj));
      } else {
        var date = this.getDate({
          step: step
        });
        this.dateObj = date;
        if (date.canBeChose) this.$emit('to', _objectSpread2({
          type: 'date'
        }, this.dateObj));
      }
    },
    getDate: function getDate(_ref) {
      var _this2 = this;

      var step = _ref.step,
          date = _ref.date;
      var dates = this.dates.reduce(function (pre, arr) {
        return pre.concat(arr);
      }, []);

      if (step !== undefined) {
        var index = Object.keys(dates).find(function (k) {
          return dates[k].year === _this2.year && dates[k].month === _this2.month && dates[k].date === _this2.date;
        });
        return dates[+index + step];
      }

      var arr = Object.keys(dates).filter(function (k) {
        return +dates[k].date === +date;
      });
      return [dates[arr[0] - 1], dates[+arr[1]]];
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "picker-items dates"
  }, [_vm.choseType === 'date' ? _c('div', {
    staticClass: "row-item h"
  }, _vm._l(_vm.$dayStr, function (item, i) {
    return _c('span', {
      key: i,
      staticClass: "item date"
    }, [_vm._v(_vm._s(item))]);
  }), 0) : _vm._e(), _vm._v(" "), _vm._l(_vm.pickerItems, function (rowItems, i) {
    return _c('div', {
      key: i,
      staticClass: "row-item"
    }, _vm._l(rowItems, function (item, j) {
      var _obj;

      return _c('span', {
        key: i + '' + j,
        staticClass: "item",
        class: (_obj = {
          'not-in-month': _vm.choseType === 'date' && !item.isInThisMonth,
          disabled: !item.canBeChose
        }, _obj[_vm.choseType] = true, _obj.selected = _vm.isSelected(item), _obj),
        on: {
          "click": function click($event) {
            return _vm.chose(item);
          }
        }
      }, [_vm._v(_vm._s(item[_vm.choseType]))]);
    }), 0);
  })], 2);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

var Date$1 = normalizeComponent_1({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

var mixin = {
  props: {
    id: [String, Number],
    value: String,
    placeholder: String,
    min: String,
    max: String,
    canEdit: {
      default: true,
      type: Boolean
    },
    inputStyle: [String, Object],
    popperProps: Object,
    scrollbarProps: Object
  },
  data: function data() {
    return {
      showPicker: false,
      defaultPopperProps: Object.freeze({
        arrowPosition: 'start',
        arrowOffsetScaling: 1,
        popperOptions: {
          placement: 'bottom-start',
          modifiers: {
            preventOverflow: {
              boundariesElement: typeof document !== 'undefined' ? document.body : ''
            }
          }
        }
      })
    };
  },
  computed: {
    $popperProps: function $popperProps() {
      return objectDeepMerge({}, this.defaultPopperProps, this.popperProps);
    },
    isMobile: function isMobile() {
      return this.scrollbarProps && this.scrollbarProps.isMobile;
    }
  },
  methods: {
    hide: function hide() {
      var _hide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (_typeof(_hide) === 'object') {
        var target = _hide.target;

        if (!(target && this.$refs.wrap.contains(target))) {
          this.showPicker = !_hide;
        }
      } else this.showPicker = !_hide;
    },
    choseHeadType: function choseHeadType(val) {
      var _this = this;

      setTimeout(function () {
        _this.choseType = val;
      });
    }
  },
  components: {
    popper: VuePopper
  },
  beforeMount: function beforeMount() {
    this.blur(this.value, false);
    window.addEventListener('click', this.hide);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('click', this.hide);
  }
};

//
var script$1 = {
  mixins: [mixin],
  name: 'Datepicker',
  props: {
    dayStr: Array
  },
  data: function data() {
    return {
      dateObj: {},
      choseType: 'date',
      showBtn: {
        prev: true,
        next: true
      }
    };
  },
  computed: {
    tenYears: function tenYears() {
      var tenYear = Math.floor(this.dateObj.year / 10 - 0.5);
      return "".concat(tenYear * 10 + 1, " - ").concat((tenYear + 1) * 10);
    },
    myValue: function myValue() {
      var _this$dateObj = this.dateObj,
          year = _this$dateObj.year,
          month = _this$dateObj.month,
          date = _this$dateObj.date;
      var fillTo$1 = fillTo;
      return "".concat(fillTo$1(4, year), "-").concat(fillTo$1(2, month), "-").concat(fillTo$1(2, date));
    },
    minDate: function minDate() {
      if (this.min && !dateReg.test(this.min)) {
        console.warn('Datepicker: prop min is invalid');
        return '';
      }

      return this.min;
    },
    maxDate: function maxDate() {
      if (this.max && !dateReg.test(this.max)) {
        console.warn('Datepicker: prop max is invalid');
        return '';
      }

      return this.max;
    }
  },
  watch: {
    value: function value(val) {
      if (val !== this.myValue) this.blur(val, false);
    }
  },
  methods: {
    inputEnter: function inputEnter(ev) {
      var value = ev.target.value;

      if (dateReg.test(value) || !value) {
        this.hide();
        ev.target.blur();
      }
    },
    blur: function blur(ev) {
      var isBlur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = isBlur ? ev.target.value : ev;

      if (value !== this.myValue) {
        if (dateReg.test(value)) {
          var date = parseDate(value.match(dateReg)[1]);

          if (dateCompare(date, this.minDate) && dateCompare(date, this.maxDate, -1)) {
            this.dateObj = date;
            if (isBlur) this.$emit('input', this.myValue);
          } else if (!isBlur) {
            console.warn('vue-datepicker: Datepicker: prop value is out of range');
            this.$emit('input', '');
          }
        } else {
          if (value) console.warn('vue-datepicker: Datepicker: prop value is invalid');
          this.$emit('input', '');
        }
      } else {
        this.$forceUpdate();
      }
    },
    chose: function chose(val) {
      this.dateObj = val;

      if (val.type === 'date') {
        this.$emit('input', this.myValue);
        this.hide();
      } else if (val.type === 'month') {
        this.choseType = 'date';
      } else if (val.type === 'year') {
        this.choseType = 'month';
      }
    }
  },
  components: {
    Date: Date$1
  }
};

/* script */
var __vue_script__$1 = script$1;
/* template */

var __vue_render__$1 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    ref: "wrap",
    staticClass: "datepicker"
  }, [_c('input', {
    staticClass: "vue-input",
    style: _vm.inputStyle,
    attrs: {
      "id": _vm.id,
      "placeholder": _vm.placeholder,
      "readonly": !_vm.canEdit || _vm.isMobile
    },
    domProps: {
      "value": _vm.value
    },
    on: {
      "click": function click($event) {
        _vm.canEdit ? _vm.hide(false) : '';
      },
      "keyup": function keyup($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        return _vm.inputEnter($event);
      },
      "blur": _vm.blur
    }
  }), _vm._v(" "), _vm.canEdit && _vm.showPicker ? _c('popper', {
    staticClass: "picker",
    attrs: {
      "referenceElm": _vm.$refs.wrap,
      "popperOptions": _vm.$popperProps.popperOptions,
      "arrowOffsetScaling": _vm.$popperProps.arrowOffsetScaling,
      "arrowPosition": _vm.$popperProps.arrowPosition
    }
  }, [_c('div', {
    staticClass: "picker-head"
  }, [_c('span', {
    staticClass: "prev",
    class: {
      disabled: !_vm.showBtn.prev
    },
    on: {
      "click": function click($event) {
        _vm.showBtn.prev ? _vm.$refs.dateCom.to(-1) : '';
      }
    }
  }, [_vm._v("<")]), _vm._v(" "), _c('span', {
    staticClass: "picker-h"
  }, [_vm.choseType === 'date' || _vm.choseType === 'month' ? _c('span', {
    staticClass: "year",
    on: {
      "click": function click($event) {
        return _vm.choseHeadType('year');
      }
    }
  }, [_vm._v(_vm._s(_vm.dateObj.year))]) : _vm.choseType === 'year' ? _c('span', [_vm._v(_vm._s(_vm.tenYears))]) : _vm._e(), _vm._v(" "), _vm.choseType === 'date' ? [_vm._v("\n           - \n          "), _c('span', {
    staticClass: "month",
    on: {
      "click": function click($event) {
        return _vm.choseHeadType('month');
      }
    }
  }, [_vm._v(_vm._s(_vm.dateObj.month))])] : _vm._e()], 2), _vm._v(" "), _c('span', {
    staticClass: "next",
    class: {
      disabled: !_vm.showBtn.next
    },
    on: {
      "click": function click($event) {
        _vm.showBtn.next ? _vm.$refs.dateCom.to(1) : '';
      }
    }
  }, [_vm._v(">")])]), _vm._v(" "), _c('date', {
    ref: "dateCom",
    attrs: {
      "value": _vm.value,
      "type": _vm.choseType,
      "minDate": _vm.minDate,
      "maxDate": _vm.maxDate,
      "dayStr": _vm.dayStr
    },
    on: {
      "chose": _vm.chose,
      "to": _vm.chose,
      "emitData": function emitData($event) {
        _vm.showBtn = $event.showBtn;
      }
    }
  })], 1) : _vm._e()], 1);
};

var __vue_staticRenderFns__$1 = [];
/* style */

var __vue_inject_styles__$1 = undefined;
/* scoped */

var __vue_scope_id__$1 = undefined;
/* module identifier */

var __vue_module_identifier__$1 = undefined;
/* functional template */

var __vue_is_functional_template__$1 = false;
/* style inject */

/* style inject SSR */

var Datepicker = normalizeComponent_1({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, undefined, undefined);

var timeReg = /^((\d{1,2}):?(\d{1,2})?:?(\d{1,2})?)/;
function timeCompare(t1, t2) {
  var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'second';
  if (!t2 || !t1) return true;
  var t11 = _typeof(t1) === 'object' ? t1 : parseTime(t1);
  var t21 = _typeof(t2) === 'object' ? t2 : parseTime(t2);

  if (flag !== 0) {
    if (type === 'hour') return (t11.hour - t21.hour) * flag >= 0;

    if (type === 'minute') {
      return (t11.hour - t21.hour) * flag > 0 || +t11.hour === +t21.hour && (t11.minute - t21.minute) * flag >= 0;
    }

    return (t11.hour - t21.hour) * flag > 0 || +t11.hour === +t21.hour && (t11.minute - t21.minute) * flag > 0 || +t11.hour === +t21.hour && +t11.minute === +t21.minute && (t11.second - t21.second) * flag >= 0;
  }

  if (type === 'hour') return t11.hour - t21.hour === 0;

  if (type === 'minute') {
    return +t11.hour === +t21.hour && t11.minute - t21.minute === 0;
  }

  return +t11.hour === +t21.hour && +t11.minute === +t21.minute && t11.second - t21.second === 0;
}

var script$2 = {
  name: 'Time',
  beforeMount: function beforeMount() {
    var _this = this;

    this.setValue(function () {
      var now = new Date();
      _this.timeObj = {
        hour: _this.fillTo(2, now.getHours()),
        minute: _this.fillTo(2, now.getMinutes()),
        second: _this.fillTo(2, now.getSeconds())
      };
    });
  },
  props: {
    value: String,
    type: String,
    scrollbarProps: Object,
    minTime: String,
    maxTime: String,
    timeStr: Array
  },
  data: function data() {
    return {
      hour: '00',
      minute: '00',
      second: '00'
    };
  },
  computed: {
    myType: function myType() {
      return /^(hour|minute|second)$/.test(this.type) ? this.type : 'second';
    },
    $scrollbarProps: function $scrollbarProps() {
      return _objectSpread2({
        maxHeight: 200
      }, this.scrollbarProps);
    },
    $timeStr: function $timeStr() {
      var arr = !this.timeStr || this.timeStr.length < 3 || this.timeStr.some(function (day) {
        return typeof day !== 'string';
      }) ? ['时', '分', '秒'] : this.timeStr.slice(0, 3);
      if (this.myType === 'hour') return arr.slice(0, 1);
      if (this.myType === 'minute') return arr.slice(0, 2);
      return arr.slice(0, 3);
    },
    minT: function minT() {
      return _objectSpread2({}, {
        hour: 0,
        minute: 0,
        second: 0
      }, {}, this.minTime && parseTime(this.minTime));
    },
    maxT: function maxT() {
      return _objectSpread2({}, {
        hour: 23,
        minute: 59,
        second: 59
      }, {}, this.maxTime && parseTime(this.maxTime));
    },
    timeObj: {
      get: function get() {
        return {
          hour: this.hour,
          minute: this.minute,
          second: this.second
        };
      },
      set: function set(val) {
        this.hour = this.fillTo(2, val.hour);
        this.minute = this.fillTo(2, val.minute);
        this.second = this.fillTo(2, val.second);
      }
    },
    hours: function hours() {
      return getHour({
        min: this.minT.hour,
        max: this.maxT.hour
      });
    },
    minutes: function minutes() {
      return getMinute({
        min: +this.hour === this.minT.hour ? this.minT.minute : 0,
        max: +this.hour === this.maxT.hour ? this.maxT.minute : 59
      });
    },
    seconds: function seconds() {
      return getSecond({
        min: +this.hour === this.minT.hour && +this.minute === this.minT.minute ? this.minT.second : 0,
        max: +this.hour === this.maxT.hour && +this.minute === this.maxT.minute ? this.maxT.second : 59
      });
    },
    pickerItems: function pickerItems() {
      var obj = {
        hour: this.hours
      };
      if (this.myType === 'hour') return obj;
      obj.minute = this.minutes;
      if (this.myType === 'minute') return obj;
      obj.second = this.seconds;
      return obj;
    },
    pickerItemStyle: function pickerItemStyle() {
      if (this.myType === 'hour') return {
        width: '100%'
      };
      if (this.myType === 'minute') return {
        width: 'calc(100% / 2)'
      };
      return {
        width: 'calc(99% / 3)'
      };
    },
    scrollTo: function scrollTo() {
      return {
        hour: (this.hour - 1) / 22,
        minute: (this.minute - 1) / 58,
        second: (this.second - 1) / 58
      };
    }
  },
  watch: {
    hour: function hour() {
      if (!timeCompare(this, this.minT, 1, 'minute')) this.minute = this.fillTo(2, this.minT.minute);else if (!timeCompare(this, this.maxT, -1, 'minute')) this.minute = this.fillTo(2, this.maxT.minute);else if (!timeCompare(this, this.minT)) this.second = this.fillTo(2, this.minT.second);else if (!timeCompare(this, this.maxT, -1)) this.second = this.fillTo(2, this.maxT.second);else this.$emit('input', _objectSpread2({
        type: 'hour'
      }, this.timeObj));
    },
    minute: function minute() {
      if (!timeCompare(this, this.minT)) this.second = this.fillTo(2, this.minT.second);else if (!timeCompare(this, this.maxT, -1)) this.second = this.fillTo(2, this.maxT.second);else this.$emit('input', _objectSpread2({
        type: 'minute'
      }, this.timeObj));
    },
    second: function second() {
      this.$emit('input', _objectSpread2({
        type: 'second'
      }, this.timeObj));
    },
    value: function value() {
      this.setValue();
    }
  },
  methods: {
    fillTo: function fillTo$1(width, num) {
      return fillTo(width, num);
    },
    setValue: function setValue(cb) {
      var date = this.value && parseTime(this.value.match(timeReg)[1]);

      if (date) {
        this.timeObj = date;
      } else if (cb) {
        cb();
      }
    },
    chose: function chose(item) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'second';

      if (item.canBeChose) {
        if (type === 'second') {
          this.second = item.value;
        } else if (type === 'minute') {
          this.minute = item.value;
        } else if (type === 'hour') {
          this.hour = item.value;
        }
      }
    }
  },
  components: {
    scrollbar: VueScrollbar
  }
};

/* script */
var __vue_script__$2 = script$2;
/* template */

var __vue_render__$2 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "picker-items time"
  }, [_c('div', {
    staticClass: "row-item h"
  }, _vm._l(_vm.$timeStr, function (item, i) {
    return _c('span', {
      key: i,
      staticClass: "item second",
      style: _vm.pickerItemStyle
    }, [_vm._v(_vm._s(item))]);
  }), 0), _vm._v(" "), _vm._l(_vm.pickerItems, function (rowItems, i) {
    return _c('scrollbar', {
      key: i,
      staticClass: "row-item line",
      style: _vm.pickerItemStyle,
      attrs: {
        "isMobile": _vm.$scrollbarProps.isMobile,
        "maxHeight": _vm.$scrollbarProps.maxHeight,
        "marginToWrap": _vm.$scrollbarProps.marginToWrap,
        "scrollTo": _vm.scrollTo[i]
      }
    }, _vm._l(rowItems, function (item, j) {
      var _obj;

      return _c('span', {
        key: i + '' + j,
        staticClass: "item",
        class: (_obj = {
          disabled: !item.canBeChose
        }, _obj[i] = true, _obj.selected = +item.value === +_vm.timeObj[i], _obj),
        on: {
          "click": function click($event) {
            return _vm.chose(item, i);
          }
        }
      }, [_vm._v(_vm._s(item.value))]);
    }), 0);
  })], 2);
};

var __vue_staticRenderFns__$2 = [];
/* style */

var __vue_inject_styles__$2 = undefined;
/* scoped */

var __vue_scope_id__$2 = undefined;
/* module identifier */

var __vue_module_identifier__$2 = undefined;
/* functional template */

var __vue_is_functional_template__$2 = false;
/* style inject */

/* style inject SSR */

var TimePin = normalizeComponent_1({
  render: __vue_render__$2,
  staticRenderFns: __vue_staticRenderFns__$2
}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, undefined, undefined);

var script$3 = {
  mixins: [mixin],
  name: 'DatetimePicker',
  props: {
    dayStr: Array,
    timeStr: Array,
    btnStr: String
  },
  data: function data() {
    return {
      timeObj: {},
      choseType: 'date',
      showBtn: {
        prev: true,
        next: true
      }
    };
  },
  computed: {
    tenYears: function tenYears() {
      var tenYear = Math.floor(this.timeObj.year / 10 - 0.5);
      return "".concat(tenYear * 10 + 1, " - ").concat((tenYear + 1) * 10);
    },
    $btnStr: function $btnStr() {
      return this.btnStr || '确定';
    },
    minDate: function minDate() {
      return this.split(this.min).date;
    },
    minTime: function minTime() {
      return dateCompare(this.split(this.myValue).date, this.minDate, 0) ? this.split(this.min).time : '0';
    },
    maxDate: function maxDate() {
      return this.split(this.max).date;
    },
    maxTime: function maxTime() {
      return dateCompare(this.split(this.myValue).date, this.maxDate, 0) ? this.split(this.max).time : '23:59:59';
    },
    myValue: function myValue() {
      var _this$timeObj = this.timeObj,
          year = _this$timeObj.year,
          month = _this$timeObj.month,
          date = _this$timeObj.date,
          _this$timeObj$hour = _this$timeObj.hour,
          hour = _this$timeObj$hour === void 0 ? '--' : _this$timeObj$hour,
          _this$timeObj$minute = _this$timeObj.minute,
          minute = _this$timeObj$minute === void 0 ? '--' : _this$timeObj$minute,
          _this$timeObj$second = _this$timeObj.second,
          second = _this$timeObj$second === void 0 ? '--' : _this$timeObj$second;
      var fillTo$1 = fillTo;
      return "".concat(fillTo$1(4, year), "-").concat(fillTo$1(2, month), "-").concat(fillTo$1(2, date), " ").concat(fillTo$1(2, hour), ":").concat(fillTo$1(2, minute), ":").concat(fillTo$1(2, second));
    }
  },
  methods: {
    split: function split(val) {
      var arr = val ? val.split(/\s/) : [];
      return {
        date: dateReg.test(arr[0]) ? arr[0] : '',
        time: timeReg.test(arr[1]) ? arr[1] : ''
      };
    },
    fillTo: function fillTo$1(width, num) {
      return fillTo(width, num);
    },
    inputEnter: function inputEnter(ev) {
      var value = ev.target.value;

      var _this$split = this.split(value),
          date = _this$split.date,
          time = _this$split.time;

      if (dateReg.test(date) && timeReg.test(time) || !value) {
        this.hide();
        ev.target.blur();
      }
    },
    blur: function blur(ev) {
      var isBlur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = isBlur ? ev.target.value : ev;

      if (value !== this.myValue) {
        var _this$split2 = this.split(value),
            date = _this$split2.date,
            time = _this$split2.time;

        if (dateReg.test(date) && timeReg.test(time)) {
          var dateObj = parseDate(date.match(dateReg)[0]);
          var timeObj = parseTime(time.match(timeReg)[0]);
          var dateGt = dateCompare(dateObj, this.minDate, 1) && dateCompare(dateObj, this.maxDate, -1);

          if (dateGt && timeCompare(timeObj, this.minTime, 1, this.myType) && timeCompare(timeObj, this.maxTime, -1, this.myType) || dateGt && !dateCompare(dateObj, this.minDate, 0) && !dateCompare(dateObj, this.maxDate, 0)) {
            this.timeObj = _objectSpread2({}, dateObj, {}, timeObj);
            if (isBlur) this.$emit('input', this.myValue);
          } else if (!isBlur) {
            console.warn('vue-datepicker: DatetimePicker: prop value is out of range');
            this.$emit('input', '');
          }
        } else {
          if (value) console.warn('vue-datepicker: DatetimePicker: prop value is invalid');
          this.$emit('input', '');
        }
      } else {
        this.$forceUpdate();
      }
    },
    chose: function chose(val) {
      this.timeObj = _objectSpread2({}, this.timeObj, {}, val);

      if (val.type === 'date') {
        this.choseType = 'time';
      } else if (val.type === 'month') {
        this.choseType = 'date';
      } else if (val.type === 'year') {
        this.choseType = 'month';
      }
    },
    input: function input(val) {
      this.timeObj = _objectSpread2({}, this.timeObj, {}, val);
      this.$emit('input', this.myValue);
    }
  },
  components: {
    TimePin: TimePin,
    Date: Date$1
  }
};

/* script */
var __vue_script__$3 = script$3;
/* template */

var __vue_render__$3 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    ref: "wrap",
    staticClass: "datetime-picker"
  }, [_c('input', {
    staticClass: "vue-input",
    style: _vm.inputStyle,
    attrs: {
      "id": _vm.id,
      "placeholder": _vm.placeholder,
      "readonly": !_vm.canEdit || _vm.isMobile
    },
    domProps: {
      "value": _vm.value
    },
    on: {
      "click": function click($event) {
        _vm.canEdit ? _vm.hide(false) : '';
      },
      "keyup": function keyup($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        return _vm.inputEnter($event);
      },
      "blur": _vm.blur
    }
  }), _vm._v(" "), _vm.canEdit && _vm.showPicker ? _c('popper', {
    staticClass: "picker",
    attrs: {
      "referenceElm": _vm.$refs.wrap,
      "popperOptions": _vm.$popperProps.popperOptions,
      "arrowOffsetScaling": _vm.$popperProps.arrowOffsetScaling,
      "arrowPosition": _vm.$popperProps.arrowPosition
    }
  }, [_c('div', {
    staticClass: "picker-head"
  }, [_c('span', {
    staticClass: "prev",
    class: {
      disabled: !_vm.showBtn.prev
    },
    on: {
      "click": function click($event) {
        _vm.showBtn.prev ? _vm.$refs.dateCom.to(-1) : '';
      }
    }
  }, [_vm._v("<")]), _vm._v(" "), _c('span', {
    staticClass: "picker-h"
  }, [_vm.choseType === 'date' || _vm.choseType === 'month' || _vm.choseType === 'time' ? _c('span', {
    staticClass: "year",
    on: {
      "click": function click($event) {
        return _vm.choseHeadType('year');
      }
    }
  }, [_vm._v(_vm._s(_vm.timeObj.year))]) : _vm.choseType === 'year' ? _c('span', [_vm._v(_vm._s(_vm.tenYears))]) : _vm._e(), _vm._v(" "), _vm.choseType === 'date' || _vm.choseType === 'time' ? [_vm._v("\n           - \n          "), _c('span', {
    staticClass: "month",
    on: {
      "click": function click($event) {
        return _vm.choseHeadType('month');
      }
    }
  }, [_vm._v(_vm._s(_vm.timeObj.month))])] : _vm._e(), _vm._v(" "), _vm.choseType === 'time' ? [_vm._v("\n           - \n          "), _c('span', {
    staticClass: "date",
    on: {
      "click": function click($event) {
        return _vm.choseHeadType('date');
      }
    }
  }, [_vm._v(_vm._s(_vm.timeObj.date))])] : _vm._e()], 2), _vm._v(" "), _c('span', {
    staticClass: "next",
    class: {
      disabled: !_vm.showBtn.next
    },
    on: {
      "click": function click($event) {
        _vm.showBtn.next ? _vm.$refs.dateCom.to(1) : '';
      }
    }
  }, [_vm._v(">")])]), _vm._v(" "), _vm.choseType === 'time' ? _c('time-pin', {
    attrs: {
      "value": _vm.split(_vm.value).time,
      "type": _vm.type,
      "scrollbarProps": _vm.scrollbarProps,
      "minTime": _vm.minTime,
      "maxTime": _vm.maxTime,
      "timeStr": _vm.timeStr
    },
    on: {
      "input": _vm.input
    }
  }) : _vm._e(), _vm._v(" "), _c('date', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.choseType !== 'time',
      expression: "choseType !== 'time'"
    }],
    ref: "dateCom",
    attrs: {
      "value": _vm.split(_vm.value).date,
      "type": _vm.choseType,
      "minDate": _vm.minDate,
      "maxDate": _vm.maxDate,
      "dayStr": _vm.dayStr
    },
    on: {
      "chose": _vm.chose,
      "to": _vm.chose,
      "emitData": function emitData($event) {
        _vm.showBtn = $event.showBtn;
      }
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "btns"
  }, [_c('span', {
    staticClass: "btn btn-sure",
    on: {
      "click": function click($event) {
        _vm.$emit('input', _vm.myValue);

        _vm.hide();
      }
    }
  }, [_vm._v(_vm._s(_vm.$btnStr))])])], 1) : _vm._e()], 1);
};

var __vue_staticRenderFns__$3 = [];
/* style */

var __vue_inject_styles__$3 = undefined;
/* scoped */

var __vue_scope_id__$3 = undefined;
/* module identifier */

var __vue_module_identifier__$3 = undefined;
/* functional template */

var __vue_is_functional_template__$3 = false;
/* style inject */

/* style inject SSR */

var DatetimePicker = normalizeComponent_1({
  render: __vue_render__$3,
  staticRenderFns: __vue_staticRenderFns__$3
}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, undefined, undefined);

//
var script$4 = {
  mixins: [mixin],
  name: 'Timepicker',
  props: {
    timeStr: Array,
    btnStr: String
  },
  data: function data() {
    return {
      timeObj: {}
    };
  },
  computed: {
    myType: function myType() {
      return /^(hour|minute|second)$/.test(this.type) ? this.type : 'second';
    },
    $btnStr: function $btnStr() {
      return this.btnStr || '确定';
    },
    myValue: function myValue() {
      var _this$timeObj = this.timeObj,
          hour = _this$timeObj.hour,
          minute = _this$timeObj.minute,
          second = _this$timeObj.second;
      return "".concat(this.fillTo(2, hour), ":").concat(this.fillTo(2, minute), ":").concat(this.fillTo(2, second));
    },
    minTime: function minTime() {
      if (this.min && !timeReg.test(this.min)) {
        console.warn('Timepicker: prop min is invalid');
        return '';
      }

      return this.min;
    },
    maxTime: function maxTime() {
      if (this.max && !timeReg.test(this.max)) {
        console.warn('Timepicker: prop max is invalid');
        return '';
      }

      return this.max;
    }
  },
  watch: {
    value: function value(val) {
      if (this.myValue === val) this.blur(val, false);
    }
  },
  methods: {
    fillTo: function fillTo$1(width, num) {
      return fillTo(width, num);
    },
    inputEnter: function inputEnter(ev) {
      var value = ev.target.value;

      if (timeReg.test(value) || !value) {
        this.hide();
        ev.target.blur();
      }
    },
    blur: function blur(ev) {
      var isBlur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = isBlur ? ev.target.value : ev;

      if (value !== this.myValue) {
        if (timeReg.test(value)) {
          var time = parseTime(value.match(timeReg)[0]);

          if (timeCompare(time, this.minTime, 1, this.myType) && timeCompare(time, this.maxTime, -1, this.myType)) {
            this.timeObj = time;
            if (isBlur) this.$emit('input', this.myValue);
          } else if (!isBlur) {
            console.warn('vue-datepicker: Timepicker: prop value is out of range');
            this.$emit('input', '');
          }
        } else {
          if (value) console.warn('vue-datepicker: Timepicker: prop value is invalid');
          this.$emit('input', '');
        }
      } else {
        this.$forceUpdate();
      }
    },
    input: function input(val) {
      this.timeObj = val;
      this.$emit('input', this.myValue);
    }
  },
  components: {
    TimePin: TimePin
  }
};

/* script */
var __vue_script__$4 = script$4;
/* template */

var __vue_render__$4 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    ref: "wrap",
    staticClass: "timepicker"
  }, [_c('input', {
    staticClass: "vue-input",
    style: _vm.inputStyle,
    attrs: {
      "id": _vm.id,
      "placeholder": _vm.placeholder,
      "readonly": !_vm.canEdit || _vm.isMobile
    },
    domProps: {
      "value": _vm.value
    },
    on: {
      "click": function click($event) {
        _vm.canEdit ? _vm.hide(false) : '';
      },
      "keyup": function keyup($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        return _vm.inputEnter($event);
      },
      "blur": _vm.blur
    }
  }), _vm._v(" "), _vm.canEdit && _vm.showPicker ? _c('popper', {
    staticClass: "picker",
    attrs: {
      "referenceElm": _vm.$refs.wrap,
      "popperOptions": _vm.$popperProps.popperOptions,
      "arrowOffsetScaling": _vm.$popperProps.arrowOffsetScaling,
      "arrowPosition": _vm.$popperProps.arrowPosition
    }
  }, [_c('time-pin', {
    attrs: {
      "scrollbarProps": _vm.scrollbarProps,
      "value": _vm.value,
      "type": _vm.type,
      "minTime": _vm.minTime,
      "maxTime": _vm.maxTime,
      "timeStr": _vm.timeStr
    },
    on: {
      "input": _vm.input
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "btns"
  }, [_c('span', {
    staticClass: "btn btn-sure",
    on: {
      "click": function click($event) {
        _vm.$emit('input', _vm.myValue);

        _vm.hide();
      }
    }
  }, [_vm._v(_vm._s(_vm.$btnStr))])])], 1) : _vm._e()], 1);
};

var __vue_staticRenderFns__$4 = [];
/* style */

var __vue_inject_styles__$4 = undefined;
/* scoped */

var __vue_scope_id__$4 = undefined;
/* module identifier */

var __vue_module_identifier__$4 = undefined;
/* functional template */

var __vue_is_functional_template__$4 = false;
/* style inject */

/* style inject SSR */

var Timepicker = normalizeComponent_1({
  render: __vue_render__$4,
  staticRenderFns: __vue_staticRenderFns__$4
}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, undefined, undefined);

export { Datepicker, DatetimePicker, Timepicker };
